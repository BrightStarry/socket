2016年12月17日 13:36:20
	虽然一直都说javaSE很重要，但是以我目前的状况来说，并没有怎么感受到。但是，这些基础知识也的的确确是要巩固的。
	我目前的准备学习过程是  IO NIO WebSocket.
	昨晚稍稍看了javaIO的基础知识，说一下：
-----------------------------------------------------------------------------------
字节流 和字符流                   输入流 和 输出流   
节点流 和 处理流   这个需要注意的是  节点流就是对一个目标进行读写的IO流，例如 文件 、数组、通道等。创建处理流时必须放入
一个节点流作为参数，也就是说，处理流是对节点流的处理。
------------------------------------------------------------------------------------
字节流  
	基类是 InputStream 和 OutputStream  并且几乎所有子类都是用这两个基类的类名作为结尾。
字符流
	基类是 Reader 和 Writer  并且所有的子类也都是用两个基类的类名结尾。
------------------------------------------------------------------------
File类 路径分隔符  /  \\  File.sepatator  注意：使用File.separator的时候，盘符后面还需要加 :
-------------------------------------------------------------------------------------
IO流中还有  mark() 和 reset()  
	可以使用markSupport()方法判断该IO类是否支持mark reset方法 -似乎只有缓冲IO才支持
	mark(int readLimit)方法表示标记当前位置，并限制 调用此方法后最多只能读取readLimit个字节.
如果超过这个限制，mark标志就会失效，调用reset()时就会抛出异常.
	上面的是官方文档中的说法，但在实际运用中，据网上的说法是，只要缓冲区足够大，mark后读取的字节没有超出缓冲区
的大小，标记就不会失效。
	在记录下对mark() reset()方法的通俗理解（这些都是网上抄的，目前没有证实）
	mark就书签一样，在读取的buffer（缓冲区）作个标记，当再次调用reset()方法就可以回到这个位置。
----------------------------------------------------------------------------------
注意一点  FileInputStream()之类的构造方法并不一定需要传入File对象，如果传入的是String，会自动转换成File。
---------------------------------------------------------------------------------
ObjectInputStream 和 ObjectOutStream 是对java对象进行读写的IO类，可以将实现serializable接口的对象
读写到一个文件。并且对象的成员变量的值也可以被保存。除了定义为static 或者transient（瞬时）的变量。
transient是java中的关键字.
只是我不明白为什么一个类非要实现serializable接口才能被序列化，看了下源码，还发现这个接口是空的。百度了下，
说是，实现这个接口只是一个标志，告诉java这个类可以被序列化。。。

另外，如果要序列化的对象只是某个实体类中的某个成员变量，也就是说，只是基本类型或者String,那么就可以使用
DataInputStream 和 DataOutputStream、
注意，上面这两个方法似乎都需要知道文件中有几个被序列化的对象，并且知道确切的类型，才能够很好的转换。
---------------------------------------------------------------------------------
刚刚在百度看到一个博客，写的很不错，我简单复述一下.
BufferedInputStream 是处理流，只能套在某个InputStream外，起到缓冲，提高性能的作用。
另外，缓冲区可以这么理解，假设要抓100条鱼，如果没有桶，只能一次1条的抓，要100次。如果有一个能装10条鱼的桶，
就可以10条10条的抓，也就是说如果有一次抓多了，也可以先放桶里。
-------------------------------------------------------------------------------
看见BufferedInputStream 有两种read()方法  分别是   
read(byte[] b) 和 read(byte[] b,int off,int length)
其中第一个参数是，把读取到的字节放入的byte数组，第二个参数是偏移量，第三个参数是读取的长度。
而read()方法的源码就是调用 后一个方法，其中off为0，length为byte[]数组的长度.
也就是说，如果只写read()方法，每次都需要多一个步骤，也就是先进入read()方法，获取到byte[]的长度，在调到
后一个read(byte[] b,int off,int length)方法。
其中需要注意的一点就是，length不能超过byte[]的长度，否则会抛出indexOutOfBoundsException
然后read()这个方法返回的值是读取到的字节个数，因为write和这个基本是一样的。所以也需要一个int length,所以
最好就是这么写：
			while((length =fis.read(buffer,0,bufferLength))!= -1){
				fos.write(buffer, 0, length);
			}
-----------------------------------------------------------------------------
有个 PushbackInputStream 可以在读取的时候，也就是while循环中，遍历读取到的缓冲区数据，进行一些操作。
也就是read()方法返回的不是读取到的字节长度，而是返回读取到的东西。 注意：它只是输入（读取）流
-----------------------------------------------------------------------------
SequenceInputStream 
 *当需要从多个输入流中读取数据的时候可以用这个 ,它可以将与之连接的多个输入流从第一个开始读取知道最后
 *一个输入流的文件末尾为止
 *可接收枚举类所封装的多个字节流对象
 *突然发现还是称为序列流比较适合， 因为是把多个输入流合并成一个序列 读取嘛
 给SequenceInputStream 创建对象的时候，只能一个个传入输入流，或者用枚举传入
 
 Enumeration是一个接口.定义了从数据结构获取连续数据的方法
 ------------------------------------------------------------------------------
 打完了那个博客上的字节流，看见还少了个StringBuffer IO .本来想写下的。。忽然发现原来这个类已经过时了。
 ---------------------------------------------------------------------------
 http://www.tuicool.com/articles/67nu6vv   一篇很好的介绍PrintStream的博客
 --------------------------------------------------------------------------------
 简单的看了，就是PrintStream可以很方便地把字节转换成指定编码的字符输出到File中。
 注意字符用print(),字符用write()
 -------------------------------------------------------------------------------------
 new FileOutputStream(f,true) 。这个true表示往文件中追加
 ----------------------------------------------------------------------------
 
 
 
 字符流
------------------------------------------------------------------------------
InputStreamReader 是把字节流转成字符流的包装类
-------------------------------------------------------------------------
Reader 或者FileReader 的每次读取都是对底层字符或者字节作的开销很大的读取，
所以一般用BufferedReader包装他们。
---------------------------------------------------------------------
 事实证明  FileReader或者FileWriter 都无法处理乱码问题 
 ----------------------------------------------------------------------------
 FileReader 无法包装任何 IO类
 ---------------------------------------------------------------------------
 new BufferedReader(new InputStreamReader(new FileInputStream("D:/桌面/Desktop/IOTest/6.txt"), "gbk"));
 处理乱码，，但是我现在貌似用UTF-8还是乱码。。。
 ------------------------------------------------------------------------------
 2016年12月18日 12:51:52
 已经解决了，可以使用UTF-8不乱码了。原因很简单，就是文件的编码不是UTF-8.所以最好在开始之前判断下文件的编码格式，然后
 使用对应的编码就可以了。
 ------------------------------------------------------------------------------------